%Autor: _ese
%_ese: 21

\chapter{El intérprete de comandos}
\label{comandos.tex}
\index{Comandos, intérprete}
\section{¿Qué es un intérprete de comandos?}

Si  bien  manejarse en  Linux  es  cada vez  más  fácil,  debido a  la
proliferación  de escritorios,  los  comienzos no  siempre fueron  así
de  fáciles. De  hecho,  puede  ocurrir que  nos  encontremos con  una
emergencia  en el  que  no  nos quede  más  remedio  que trabajar  con
comandos.

Un intérprete  de comandos tiene el  aspecto de una pantalla  llena de
letras, generalmente con fondo  negro y letras blancas\footnote{Aunque
inicialmente  eran  de fondo  negro  con  letras  de color  naranja  o
verde.}, y que en la última línea inferior, se suele ver lo siguiente:

\begin{verbatim}
[cila@gulic]$
\end{verbatim}

En  este entorno  es donde  introduciremos  los comandos  con los  que
trabajaremos, y  coloquialmente diremos que estamos  trabajando en una
consola. Estos comandos pueden ser de diferentes clases:

\begin{itemize}
\item Programas ejecutables.

\item Scripts (guiones) del intérprete.

\item Scripts (guiones) de lenguajes de  script como {\sf Python},  {\sf Perl},
{\sf Tcl}, etc.

\item Macros del intérprete.
\end{itemize}

Todos  tienen en  común que  son ficheros:  al cargar  un programa  en
Linux, se ordena al intérprete que busque el fichero con el nombre del
programa y una vez encontrado, lo ejecute si el usuario tiene permisos
de ejecución.

Los comandos tienen el siguiente aspecto:

\begin{verbatim}
[cila@gulic]$ fdisk
[cila@gulic]$ lsmod
[cila@gulic]$ ls
\end{verbatim}

También funcionan con opciones:

\begin{verbatim}
[cila@gulic]$ fdisk -v
[cila@gulic]$ ls -a -l
[cila@gulic]$ ls -al
\end{verbatim}

Y con parámetros:

\begin{verbatim}
[cila@gulic]$ fdisk /dev/hda
[cila@gulic]$ ls /tmp
[cila@gulic]$ ls *.txt
\end{verbatim}

Con opciones y parámetros:

\begin{verbatim}
[cila@gulic]$ rpm -qpl joe-1.0.3.rpm
[cila@gulic]$ gcc -o suma suma.c
[cila@gulic]$ ls -al /tmp
\end{verbatim}

Al  ser Linux  un sistema  {\em multitarea}  y {\em  multiusuario}, se
aportan  ventajas que  se  agradecen  incluso en  un  sistema PC  {\em
monousuario}.  Una de  estas ventajas  es  que se  puede trabajar  con
seis  consolas  virtuales, que  es  como  si pudiéramos  trabajar  con
varias  sesiones  simultáneas, entendiendo  por  sesión  el tiempo  de
trabajo  desde que  el usuario  entra  tras identificarse  en el  {\tt
login}\index{login} de entrada  hasta que abandona el  sistema. Lo que
significa realmente que el mismo  usuario puede entrar varias veces al
mismo tiempo.

Para alternar  entre estas  consolas virtuales,  basta con  pulsar las
combinaciones de  la teclas  {\tt A-F1} a  {\tt A-F6}.

\begin{nota}
En lo sucesivo usaremos esta nomenclatura:\\
\vspace{-1cm}
\begin{itemize}
\setlength{\itemsep}{-15pt}
\item {\tt A-F1} $\Rightarrow$ {\tt Alt} y {\tt  F1}.\\
\item {\tt C-F1} $\Rightarrow$ {\tt Control} y {\tt F1}.\\
\item {\tt S-F1} $\Rightarrow$ {\tt Shift}  y {\tt F1}.\\
\end{itemize}
\vspace{-1cm}
Donde {\tt Shift} es la tecla de las mayúsculas.
\end{nota}

Si se quiere acceder a una  consola desde un entorno gráfico, entonces
se pulsan las combinaciones {\tt C-A-F1} a {\tt C-A-F6}

\section{Directorios y nombres de ficheros}

\subsection{Trabajar con directorios.}

\subsubsection{Estructura del árbol de directorios}

Toda  la información  (ya  sean  textos, imágenes,  bases  de datos  o
información para  la configuración  del sistema)  se almacena  en {\em
ficheros}, que a su vez se guardan en {\em directorios}. Con todas las
herramientas y programas existentes se  puede acceder a estos ficheros
para ver su contenido o  modificarlo. En la Figura \ref{arbol} podemos
ver una ejemplo de dicha estructura en árbol.

\begin{figura}{arbol}{0.7}
\caption{Estructura    en   árbol    de   directorios    en   sistemas
UNIX}\label{arbol}
\end{figura}

Todos los  ficheros y  directorios de  un sistema  UNIX cuelgan  de un
directorio principal  llamado {\em raíz}\index{directorio  raíz, raíz,
/}, que se  representa como {\tt /}. En la  Figura \ref{arbol} podemos
observar como del  directorio raíz {\tt /}  cuelgan otros directorios,
como {\tt etc} o {\tt home}.

En  dicho  esquema  diferenciamos  los directorios  de  los  ficheros,
complementando el  final del  nombre de los  primeros con  el carácter
{\tt /}.  En el  mismo esquema vemos  como algunos  directorios pueden
contener otros directorios,  como es el caso de {\tt  home}, que es el
{\em padre} de los directorios {\tt usr1} y {\tt usr2}. También pueden
contener algunos  ficheros, como es  el caso de  {\tt dev}, que  es el
padre de {\tt  dsp}; o el propio  {\tt usr2}, que es el  padre de {\tt
trabajo.txt}. Este  último fichero tiene  la {\em ruta  absoluta} {\tt
/home/usr2/trabajo.txt}, que  define su localización dentro  del árbol
de directorios.

Todos  los directorios  de  un  sistema UNIX  contienen  al menos  dos
subdirectorios.  El  primero es  {\tt  ./}  que representa  al  propio
directorio,  mientras que  el segundo  es  {\tt ../}  y representa  al
directorio padre. Por  ejemplo, el directorio {\tt ./}  dentro de {\tt
/home/usr1} es el propio {\tt  /home/usr1}, mientras que el directorio
{\tt ../}  dentro de  {\tt /home/usr1}  es {\tt  /home}, es  decir, su
directorio padre.

En  los sistemas  UNIX  todo son  ficheros.  Dispositivos como  discos
duros,  scanners  o  disqueteras  se representan  como  {\em  archivos
especiales} en  el directorio  {\tt /dev}. Por  ejemplo, en  la Figura
\ref{arbol} vemos  el fichero {\tt /dev/dsp}  que suele corresponderse
con la tarjeta de sonido instalada en el sistema.

A diferencia de  los sistemas MS-DOS/Windows, en los  sistemas UNIX no
se  reparten los  directorios en  función de  si están  en una  unidad
física o en  otra ({\tt C:}, {\tt D:}, etc.).  Durante el arranque del
sistema,  cada  uno los  archivos  representativos  de los  diferentes
discos  duros, particiones  y demás  elementos de  almacenamientos son
asociados a  un directorio del directorio  raíz. A este proceso  se lo
denomina {\em montaje}\index{Montar}, y no  sólo es revesible sino que
es completamente  configurable. Por ejemplo, en  la Figura \ref{arbol}
el directorio {\tt  /home} podría estar en una  partición diferente en
un disco duro distinto al que contiene  a {\tt /} o a {\tt /etc}. Nada
en el esquema o  en el trabajo con el sistema  nos permite apreciar la
diferencia. Por  tanto, no tiene  sentido escribir en la  consola {\tt
C:}, tal  y como haríamos  en MS-DOS. Solamente debemos  dirigirnos al
directorio asociado a esa partición que para MS-DOS es {\tt C:}.

Hay que  destacar que  cuando el  usuario accede  a una  sesión, Linux
``envía'' al usuario a su directorio  de trabajo. Cuando entro como el
usuario  {\tt cila},  en  el momento  de entrar  me  encontraré en  el
directorio  {\tt /home/cila}.  Éste  será mi  directorio personal,  en
donde  tengo  libertad absoluta  para  hacer  lo  que quiera  con  mis
ficheros y directorios  ubicados ahí. Sin embargo no  podré hacer todo
lo que quiera en el directorio {\tt /home/pepe}. ¿Por qué? Pues por la
sencilla razón de que Linux tiene un sistema de permisos que concede o
restringe  libertades sobre  los  directorios y  ficheros  que hay  en
Linux. ¿Significa eso  que puede existir un usuario  ``dios'' en Linux
que puede  hacer totalmente  cualquier cosa  en Linux?  Sí, ése  es el
usuario {\tt  root}\index{root}. Sin  embargo, para los  propósitos de
este curso,  sólo nos remitiremos a  la cuenta de trabajo  del usuario
{\em cila}.


\subsubsection{Comandos sobre el árbol de directorios}

Para movernos por el árbol  de directorios emplearemos el comando {\tt
cd} ({\sf Change Directory}) \index{Comandos!cd}

\begin{verbatim}
[cila@gulic]$ cd /etc
\end{verbatim}

Es decir, nos vamos al directorio {\tt /etc}

Si  simplemente escribimos  {\tt  cd} sin  especificar  el nombre  del
directorio, esto será  igual que escribir {\tt cd  /home/cila} o {\tt
cd}, es decir,  me envía a {\bf mi propio  directorio de trabajo} (que
es como irse a casa).

¿Cómo sé  yo en  qué directorio  me encuentro?  Basta con  escribir el
comando {\tt pwd} ({\sf Print Work Directory}).
\index{Comandos!pwd}

\begin{verbatim}
[cila@gulic cila]$ pwd
/home/cila/
\end{verbatim}

Y la salida que obtendré es:

\begin{verbatim}
/home/cila
\end{verbatim}

En  caso   de  querer   listar  los   ficheros  y   subdirectorios  de
un   directorio   dado   escribimos   {\tt   ls   nombre\_directorio}.
\index{Comandos!ls}

\begin{verbatim}
[cila@gulic]$ ls /home/cila/apuntes/apuntes/
Apuntes_CILA_2001.dvi   CVS/                 introduccion.sgml 
programando.sgml        xwindow.sgml         Apuntes_CILA_2001.sgml     
editores.sgml           LEEME                recursos.sgml              
cabecera.sgml           final.sgml           Makefile                   
resumen_temario.txt     comandos.sgml        graficos.sgml
matematicas.sgml        sobre.sgml           compila*                
internet.sgml           presentacion.sgml    temario.estado
\end{verbatim}

El comando {\tt ls} admite parámetros tales como {\tt -a, -l}

\begin{verbatim}
[cila@gulic]$ ls -a -l
[cila@gulic]$ ls -al
[cila@gulic]$ ls -la
\end{verbatim}

Obsérvese que ambas  formas de escribir los  parámetros son igualmente
válidas.  Como anotación,  si queremos  ver que  parámetros se  pueden
utilizar  en   un  comando,   normalmente  basta  con   escribir  {\tt
nombre\_comando --help}.

\begin{verbatim}
[cila@gulic]$ ls --help
Modo de empleo: ls [OPCIÓN]... [FICHERO]...
Muestra información acerca de los FICHEROs (del directorio actual por defecto).
Ordena las entradas alfabéticamente si no se especifica ninguna de las
opciones -cftuSUX ni --sort.

Los argumentos obligatorios para las opciones largas son también obligatorios
para las opciones cortas
  -a, --all                  do not hide entries starting with .
  -A, --almost-all           do not list implied . and ..
      --author               print the author of each file
  -b, --escape               print octal escapes for nongraphic characters
      --block-size=TAMAÑO    utiliza bloques de TAMAÑO bytes
  -B, --ignore-backups       no muestra la entradas que terminan con ~
  -c                         con -lt: ordena por ctime y muestra ctime (fecha
                               de última modificación del fichero)
                               con -l: muestra ctime y ordena por nombre
                               en cualquier otro caso: ordena por ctime
  -C                         muestra las entradas por columnas
      --color[=CUÁNDO]       especifica si se usará color para distinguir los
                               tipos de ficheros. CUÁNDO puede ser `never',
                               `always' o `auto'
  -d, --directory            muestra las entradas de los directorios en lugar
                             de sus contenidos
  -D, --dired                genera el resultado para el modo `dired' de Emacs
  -f                         no ordena, utiliza -aU, no utiliza -lst
  -F, --classify             añade un indicador (uno de */=@|) a las entradas
      --format=PALABRA       across -x, commas -m, horizontal -x, long -l,
                               single-column -1, verbose -l, vertical -C
      --full-time            como -l --time-style=full-iso
  -g                         como -l, pero no muestra el propietario
  -G, --no-group             no muestra la información del grupo
  -h, --human-readable       muestra los tamaños de forma legible
                             (p.e. 1K 234M 2G)
      --si                   análogo, pero utilizando potencias de 1000,
                             no de 1024
  -H, --dereference-command-line  sigue los enlaces simbólicos en la línea de
                                  órdenes
      --indicator-style=PALABRA  añade un indicador con estilo PALABRA a los
                                 nombres de las entradas: none (predeterminado),
                                 classify (-F), file-type (-p)
  -i, --inode                muestra el número de nodo-i de cada fichero
  -I, --ignore=PATRÓN        no lista las entradas que coincidan (encajen)
                             con PATRÓN de shell
  -k                         como --block-size=1K
  -l                         utiliza un formato de listado largo
  -L, --dereference          al mostrar la información de un fichero para un
                               enlace simbólico, muestra la información del
                               fichero al que apunta el enlace en lugar de la
                               del propio enlace
  -m                         rellena el ancho con una lista de entradas
                             separadas por comas
  -n, --numeric-uid-gid      como -l, pero muestra los UIDs y GIDs numéricos
  -N, --literal              muestra los nombres literalmente (no trata p.ej.
                             los caracteres de control de forma especial)
  -o                         como -l, pero no muestra el grupo
  -p  --file-type            añade un indicador (uno de /=@|) a las entradas
  -q, --hide-control-chars   imprime ? en lugar de los caracteres no gráficos
      --show-control-chars   muestra los caracteres no gráficos tal y como
                             son (predeterminado a menos que el programa sea
                             `ls' y la salida sea un terminal)
  -Q, --quote-name           encierra los nombres de las entradas entre
                             comillas
      --quoting-style=PALABRA  utiliza el estilo de cita PALABRA para los
                               nombres de las entradas:
                               literal, locale, shell, shell-always, c, escape
  -r, --reverse              invierte el orden, en su caso
  -R, --recursive            muestra los subdirectorios recursivamente
  -s, --size                 muestra el tamaño de cada fichero, en bloques
  -S                         ordena los ficheros por tamaño
      --sort=PALABRA         extension -X, none -U, size -S, time -t, version -v
                             status -c, time -t, atime -u, access -u, use -u
      --time=PALABRA         muestra la fecha según PALABRA, en lugar de la
                             fecha de modificación:
                               atime, access, use, ctime ó status; utiliza
                               la fecha especificada como clave de ordenación
                               si --sort=time
      --time-style=PALABRA   muestra la fecha utilizando el estilo PALABRA:
                               full-iso, iso, locale, posix-iso, +FORMATO
                             FORMATO se interpreta como en `date'; si FORMATO
                             es FORMATO1<nuevalínea>FORMATO2, FORMATO1 se
                             aplica a los ficheros no recientes y FORMATO2
                             a los ficheros recientes
  -t                         ordena por la fecha de modificación
  -T, --tabsize=COLS         establece los topes de tabulación a cada COLS
                             en lugar de 8
  -u                         con -lt: ordena por atime y muestra atime (fecha
                               de último acceso al fichero)
                               con -l: muestra atime y ordena por nombre
                               en cualquier otro caso: ordena por atime
  -U                         no ordena; muestra las entradas en el orden del
                             directorio
  -v                         ordena por versión
  -w, --width=COLS           establece el ancho de la pantalla en lugar del
                             valor actual
  -x                         muestra las entradas por líneas en vez de por
                             columnas
  -X                         ordena alfabéticamente por la extensión de la
                             entrada
  -1                         muestra un fichero por cada línea
      --help     muestra esta ayuda y finaliza
      --version  muestra la versión y finaliza

TAMAÑO puede ser (o puede ser un entero seguido opcionalmente por) uno
de los siguientes: kB 1.000, K 1.024, MB 1.000.000, M 1.048.576, y así
en adelante para G, T, P, E, Z, Y.

Por defecto, no se emplea color para distinguir los tipos de ficheros. Esto
equivale a usar --color=none. Usar la opción --color sin el argumento opcional
CUÁNDO equivale a usar --color=always. Con --color=auto, sólo se muestran
los códigos de color si la salida estándar está conectada a un terminal (tty).

Comunicar bichos a <bug-fileutils@gnu.org>.
\end{verbatim}


Para consultar con detenimiento esta ayuda, el autor recomienda usar
{\tt ls --help | more}, y que según se avanza con la información, se
pulsa la barra espaciadora, y para salir, se pulsa la tecla {\tt q}.

Obsérvese que  se pueden  escribir los parámetros  de dos  formas: una
corta ({\tt -l, -a}) y otra larga ({\tt --all, --help}).

Para crear  un directorio, usaremos {\tt  mkdir nombre\_directorio}.

\begin{verbatim}
[cila@gulic]$ mkdir pepe
[cila@gulic]$ mkdir tmp
\end{verbatim}

Mientras que para eliminarlo  usaremos {\tt rmdir nombre\_directorio}.
%\newpage

\begin{nota}
El directorio que se quiere eliminar  debe estar vacío y no debe haber
nadie  trabajando en  él en  ese  momento. En  caso de  que haya  otro
usuario dentro, el sistema avisará con un mensaje de error y desistirá
todo intento de eliminación.
\end{nota}

Evidentemente, podemos  crear y destruir  un directorio dando  su ruta
completa o sólo  su nombre si nos encontramos en  el directorio que lo
contiene. En  caso de querer borrar  de un sólo golpe  un directorio y
todo su  contenido disponemos  del comando {\tt  rm} con  las opciones
{\tt  -rf}.

\begin{nota}
Mucho cuidado con  borrar directorios enteros sin comprobar  lo que se
hace, porque ésta es una operación irreversible.\\
\end{nota}

\begin{verbatim}
[cila@gulic]$ rmdir pepe
[cila@gulic]$ rm -rf tmp
\end{verbatim}

Obsérvese que los comandos  anteriores borran los subdirectorios {\tt
pepe} y {\tt tmp} del directorio actual. Como hemos comentado, podemos
emplear rutas absolutas  para crear o borrar  un directorio cualquiera
del árbol de directorios.

\begin{verbatim}
[cila@gulic]$ mkdir /home/cila/pepe
[cila@gulic]$ rmdir /home/cila/pepe
\end{verbatim}

\subsection{Trabajando con ficheros}

\subsubsection{Comandos sobre el árbol de ficheros}

El  comando  para  copiar  un   fichero  es  {\tt  cp  fichero\_origen
fichero\_destino}, es decir, que copiamos el fichero {\tt pepe.txt} en
{\tt juan.txt}.

\begin{verbatim}
[cila@gulic]$ cp pepe.txt juan.txt
\end{verbatim}

El   comando  para   mover  o   renombrar  un   fichero  es   {\tt  mv
fichero\_origen fichero\_destino},  es decir, que copiamos  el fichero
{\tt pepe.txt} en {\tt juan.txt},  pero {\tt pepe.txt} deja de existir
físicamente.

\begin{verbatim}
[cila@gulic]$ mv pepe.txt juan.txt
\end{verbatim}

\begin{nota}
El  intérprete  de  comandos  \textbf{SÍ} distingue  en  mayúsculas  y
minúsculas,  tanto en  el  caso de  los  comandos como  en  el de  los
ficheros y directorios. Esto significa que el comando mv es totalmente
diferente a {\tt  Mv}, {\tt mV} y {\tt MV}.  Asimismo, el fichero {\tt
pepe.txt}  no es  el mismo  fichero que  {\tt Pepe.txt},  ni que  {\tt
PEPE.TXT}, etc.
\end{nota}

En  caso de  que  deseemos borrar  definitivamente  un fichero  podemos
emplear el comando {\tt rm nombre\_fichero}.

\begin{verbatim}
[cila@gulic]$ rm pepe.txt juan.txt
\end{verbatim}

\subsubsection{Utilización de comodines}

En ocasiones el  nombre de los directorios o ficheros  sobre los que
estamos trabajando  contienen partes comunes que  podemos utilizar con
ayuda  de  comodines  para  facilitarnos  el uso  de  la  interfaz  de
comandos.

En general el carácter {\tt *} al  indicar el nombre de un fichero o
directorio  es sustituido  por  un número  indeterminado de  cualquier
combinación de caracteres. Por ejemplo,

\begin{verbatim}
[cila@gulic]$ rm pe*
\end{verbatim}

\noindent borrará cualquier  ficheros que empiecen por {\tt  pe} en el
directorio actual. Mientras que,

\begin{verbatim}
[cila@gulic]$ cp *txt* tmp/
\end{verbatim}

\noindent copiará los ficheros que contengan la cadena {\tt txt} en el
nombre al directorio {\tt tmp}.

El carácter {\tt ?} al indicar el nombre de un fichero sólo representa
a {\em un} carácter cualquiera.

\begin{verbatim}
[cila@gulic]$ mv pepe?.txt tmp/
\end{verbatim}

El  ejemplo  anterior  moverá  archivos como  {\tt  pepe.txt}  o  {\tt
pepa.txt} al directorio {\tt tmp}.

\subsubsection{Sistema de permisos}

A la hora  de trabajar con ficheros, es necesario  entender el sistema
de  permisos de  los ficheros  y  directorios. Si  escribimos {\tt  ls
-l}\index{Ficheros!permisos,  Ficheros!propietario,  Ficheros!tamaño},
nos encontramos con la siguiente salida: \index{Fichero!permisos}

\begin{verbatim}
[cila@gulic]$ ls -l
total 468
-rw-rw-r--    1 cila    cila      163004 oct 29 10:05
 Apuntes_CILA_2001.dvi
-rw-rw-r--    1 cila    cila      119151 oct 29 10:05
 Apuntes_CILA_2001.sgml
-rw-rw-r--  1 cila  cila    1617 oct 28 22:15 cabecera.sgml
-rw-rw-r--  1 cila  cila   13329 oct 29 10:05 comandos.sgml
-rwx------  1 cila  cila      33 oct 29 00:32 compila*
drwxrwxr-x  2 cila  cila    4096 oct 28 23:20 CVS/
-rw-rw-r--  1 cila  cila   17250 oct 28 12:11 editores.sgml
-rw-rw-r--  1 cila  cila      12 oct 27 23:10 final.sgml
-rw-rw-r--  1 cila  cila     157 oct 27 23:10 graficos.sgml
-rw-rw-r--  1 cila  cila    2816 oct 28 21:51 internet.sgml
-rw-rw-r--  1 cila  cila   23308 oct 28 23:05 introduccion.sgml
-rw-rw-r--  1 cila  cila     402 oct 27 23:10 LEEME
-rw-rw-r--  1 cila  cila    2295 oct 28 22:19 Makefile
-rw-rw-r--  1 cila  cila   13087 oct 28 17:30 matematicas.sgml
-rw-rw-r--  1 cila  cila     652 oct 28 21:56 presentacion.sgml
-rw-rw-r--  1 cila  cila    34797 oct 28 21:56 programando.sgml
-rw-rw-r--  1 cila  cila      47 oct 28 21:56 recursos.sgml
-rw-rw-r--  1 cila  cila    1320 oct 25 13:35 resumen_temario.txt
-rw-rw-r--  1 cila  cila    4662 oct 28 22:17 sobre.sgml
-rw-rw-r--  1 cila  cila    5247 oct 28 22:19 temario.estado
-rw-rw-r--  1 cila  cila    7417 oct 27 23:10 xwindow.sgml
\end{verbatim}

La primera letra a  la izquierda de cada línea nos  indica si se trata
de un fichero (``-'') o un directorio (``d'').

Después nos  encontramos con tres  grupos de tres letras  ({\tt rwx}),
que según estén activados (la propia letra, {\tt r},{\tt w},{\tt x}) o
desactivados (un guión,  -) nos concede o deniega  permisos de lectura
({\tt r}), escritura  ({\tt w}) y ejecución ({\tt x}).  ¿Y por qué son
tres  grupos? Pues  porque las  tres  primeras letras  se refieren  al
propio usuario que  es el dueño de esos ficheros,  el segundo grupo se
refiere al grupo de usuario que  pertenece ese usuario, y el tercero a
los  usuarios ``extraños``  o  ''ajenos'' al  usuario.  Por tanto,  si
leemos:

\begin{center}
$-\underbrace{rw-}_{u}\underbrace{rw-}_{g}\underbrace{r--}_{o}$
\end{center}

\noindent vemos que se trata de un fichero (-) con permisos de lectura
y escritura  para el usuario  y el grupo al  que pertenece, y  de sólo
lectura para un ``extraño''.

El  siguiente  sería un  fichero  de  lectura, escritura  y  ejecución
únicamente para el usuario pro\-pie\-ta\-rio del fichero.

\begin{center}
$-\underbrace{rwx}_{u}\underbrace{---}_{g}\underbrace{---}_{o}$
\end{center}

Este  último  ejemplo es  un  directorio  ({\tt  d}) con  permisos  de
lectura,  escritura y  ejecución  para el  usuario y  el  grupo, y  de
lectura y ejecución para el ``extraño''. En el caso de directorios, el
permiso de  ejecución es equivalente  a permiso para  ``ejecutar'' los
programas que hay en el directorio.

\begin{center}
$d\underbrace{rwx}_{u}\underbrace{rwx}_{g}\underbrace{r-x}_{o}$
\end{center}

En  el ejemplo  del  listado anterior  vemos dos  veces  el nombre  de
``cila''. El de la primera columna se refiere al usuario propietario,
y el segundo  es el nombre del grupo, que  casualmente coincide con el
nombre  del usuario.

\begin{nota}
Debemos tener en cuenta que {\bf  jamás podremos eliminar un fichero o
retocarlo  si no  tenemos permisos  de  escritura sobre  él}.
\end{nota}

Si queremos que un fichero cambie de propietario, lo haremos, con {\tt
chown}: \index{Comandos!chown, Ficheros!propietario}

\begin{verbatim}
[cila@gulic]$ chown miguel pepe.txt
\end{verbatim}

si antes, {\tt pepe.txt} era de {\tt  cila}, ahora pasa a ser de {\tt
miguel}.

De   igual   forma,   para   cambiarlo   de   grupo,   usaremos   {\tt
chgrp}\index{Comandos!chgrp}. Si  {\tt pepe.txt} era del  grupo de los
profesores,  y queremos  que sea  del grupo  de los  estudiantes, sólo
habrá que escribir lo siguiente:

\begin{verbatim}
[cila@gulic]$ chgrp estudiantes pepe.txt
\end{verbatim}

En algunos sistemas  no se puede cambiar el propietario  de un fichero
bajo ciertas condiciones:

\begin{verbatim}
$ ls -l hola
-rw-r--r--    1 miguev   108             0 ago 10 20:27 hola
$ chown frodo hola
chown: hola: Operación no permitida
\end{verbatim}

Esto es normal en sistemas donde hay cuotas de usuario. Las cuotas son
un mecanismo de limitación para que  los usuarios no puedan ocupar más
de un  determinado volumen (su cuota)  en el disco. Si  este mecanismo
está activo  no se permite  a los  usuarios cambiar el  propietario de
ningún fichero, ya que podría usarse  este cambio para ocupar la cuota
de otro usuario.

\index{Comandos!chmod, Ficheros!permisos}
Finalmente, para  cambiar los permisos  de un fichero, lo  haremos con
{\tt chmod},  indicando a  que tipo de  usuario queremos  asignarlos y
sobre qué permisos.  Para indicar el usuario  propietario, usaremos el
parámetro {\tt u}, el  de grupo será {\tt g} y el  ajeno será {\tt o},
(de {\tt otros}). Para indicar el tipo de permiso, usaremos las letras
{\tt  r},  {\tt w},  {\tt  x},  según  sean  de lectura,  escritura  o
ejecución  respectivamente. Y  para conceder  o denegar,  usaremos los
símbolos ``+'' y ``-'':

\begin{verbatim}
[cila@gulic]$ chmod u+rwx pepe.txt
\end{verbatim}

Este ejemplo sirve para dar todos los permisos al usuario.

En el  siquiente ejemplo  daremos permisos de  lectura y  ejecución al
usuario  y al  grupo,  pero  no de  escritura  sobre  el fichero  {\tt
compila}.

\begin{verbatim}
[cila@gulic]$ chmod ug+r-x compila
\end{verbatim}

O quitar el permiso de ejecución a  todos los usuarios sin que se vean
afectados los otros tipos de permisos:

\begin{verbatim}
[cila@gulic]$ chmod -x probar
\end{verbatim}

\section{Comandos básicos para sobrevivir}

A  parte de  los comandos  para el  manejo de  ficheros y  directorios
existen  algunos otros  que  conviene conocer  puesto que  simplifican
notablemente nuestro quehacer diario.

\subsection{Teclas especiales}

La interfaz de comandos está llena de atajos de teclado diseñados para
facilitarnos  la vida.  La  mayor parte  se  apoyan en  el  uso de  un
historial de los últimos comandos ejecutados. Éstos son algunos de los
atajos más importantes:

\begin{description}

\item[{\tt Teclas del cursor}] Las  flechas hacia arriba y hacia abajo
nos  permiten  elegir  un  comando  de entre  los  almacenados  en  el
historial de la interfaz de comandos. Las flechas hacia la izquierda y
hacia la derecha  nos permiten movernos por la línea  de comandos para
editarla.

\item[{\tt TAB}] Si  mientras escribimos el nombre de un  comando o el
de  un  fichero tenemos  alguna  duda  podemos  pulsar {\tt  TAB}.  La
interfaz de comandos nos ayudará completando el nombre en la medida de
lo posible.  En caso  de que  no sepa darnos  una respuesta  por haber
varias soluciones  disponibles podemos pulsar nuevamente  para que nos
muestre  una lista  de  las mismas.  La interfaz  de  comandos nos  lo
indicará con una señal sonora si no hay ninguna solución posible.

\item[{\tt  S-Re. Pag.  y S-Av.  Pag.}] Nos  permiten movernos  por el
búffer de  pantalla de la  consola para  ver texto que  en condiciones
normales no podemos observar puesto  que el desplazamiento vertical lo
ha dejado fuera de la misma.

\item[{\tt C-l}] Limpiar la pantalla de la consola.

\item[{\tt C-r}] Buscar comandos en el historial.

\end{description}

\subsection{Imprimir en la salida estándar}

Uno   de   los  comandos   más   prácticos   y  utilizados   es   {\tt
cat}\index{Comandos!cat}.   Dicho   comando  encadena   los   archivos
especificados y los imprime por pantalla uno detrás de otro.

\begin{verbatim}
[cila@gulic]$ cat pepe.txt juan.txt
\end{verbatim}

En realidad los comandos de la consola de GNU/Linux no entienden la
salida por pantalla y la entrada por teclado de la misma forma que la
entendemos nosotros. La mayor parte de los comandos toman toda o parte
de la información que necesitan para realizar su trabajo de lo que se
denomina la {\em entrada estándar}.  De la misma manera, utilizan la
{\em salida estándar} para mostrar los resultado de su trabajo, y la
{\em salida de error estándar} para mostrar los mensajes de los
errores producidos durante la realización de la misma.

En general la {\em entrada estándar} suele estar asociada a la entrada
por teclado, mientras que la {\em salida estándar} y la {\em salida de
error estándar}  suelen estar sociadas  a la salida por  pantalla. Sin
embargo, Linux nos proporciona mecanismos para que cualquiera de estas
{\em entrada/salidas} pueda ser redirigida a un fichero. De esa manera
la entrada  a un  comando puede haber  sido almacenada  previamente; o
podemos  guardar  la salida  de  un  comando  en  un fichero  para  su
posterior análisis.

En  todo caso  la caraterística  de la  interfaz de  comandos que  nos
interesa es aquella que permite  redirigir la {\em salida estándar} de
un comando a la {\em entrada estándar} de otro.

\begin{verbatim}
[cila@gulic]$ cat pepe.txt | sort
[cila@gulic]$ ls -l | more
\end{verbatim}

En el ejemplo  anterior utilizamos el {\em metacarácter}  {\tt |} para
redirigir la salida del comando {\tt  cat} (es decir, el contenido del
fichero  {\tt pepe.txt})  a  la  entrada del  comando  {\tt sort}.  El
comando {\tt  sort}\index{Comandos!sort} toma las líneas  de texto que
provienen de la {\em entrada estándar},  las ordena, y las muestra por
su  {\em  salida estándar}.  Por  lo  tanto,  el ejemplo  muestra  por
pantalla el contenido de {\tt pepe.txt} ordenado alfabéticamente.

En el mismo ejemplo redirigimos la  salida de {\tt ls} al comando {\tt
more}.  El comando  {\tt more}\index{Comandos!more}  resulta muy  útil
cuando  el contenido  de  un fichero  o  la salida  de  un comando  es
lo  suficientemente grande  como  para no  caber  completamente en  la
pantalla. En esos casos {\tt more} nos permite ver el texto pantalla a
pantalla, utilizando la barra espaciadora para avanzar por el mismo.

Un comando  mucho más  potente pero  con una  utilidad similar  a {\tt
more} es {\tt less}\index{Comandos!less}.

\begin{verbatim}
[cila@gulic]$ ls -l | less
\end{verbatim}

El comando {\tt less} nos permite utilizar las teclas del cursor, {\tt
Re. Pag.}  y {\tt Av.  Pag.} para avanzar  y retroceder por  el texto.
También podemos iniciar una búsqueda, o continuar una ya iniciada, con
las  teclas  {\tt  /}  y  {\tt  n}  respectivamente.  Muchas  son  las
características de {\tt less}, aunque  nos conformaremos con saber que
con {\tt  h} podemos consultar la  ayuda del comando mientras  que con
{\tt q} salimos del mismo.

En general los comandos que hemos estudiado son programas de consola
como otros cualesquiera. Por lo tanto pueden ser llamados
directamente, e incluso en muchos casos disponen de opciones de línea
de comandos.

\begin{verbatim}
[cila@gulic]$ sort -r pepe.txt
[cila@gulic]$ less pepe.txt
\end{verbatim}

\subsection{El comando {\tt man}}
\index{Comandos!man}

El comando  {\tt man} es muy  útil, ya que nos  dará mucha información
sobre la mayoría de los comandos con los que vamos a trabajar.

\begin{verbatim}
[cila@gulic]$ man bash
\end{verbatim}

Omitimos  la información  de salida  ya que  puede ser  muy extensa  e
invita al lector a que lo pruebe él mismo.

En cualquier  caso, en  el tema \ref{documentacion}  estudiaremos este
comando con más detenimiento.

\subsection{El comando {\tt gzip}}
\index{Comandos!gzip}

El comando  {\tt gzip nombre\_fichero} comprime  un fichero utilizando
el algoritmo {\sf Lempel-Ziv}.

\begin{verbatim}
[cila@gulic]$ gzip pepe.txt
búsqueda  \end{verbatim}

Por regla  general el fichero  desaparece y en  su lugar se  crea otro
comprimido y con el mismo nombre más el sufijo {\tt .gz}.

La  descompresión  se  realiza  utilizando  la  opción  {\tt  -d}.  Es
importante destacar  que, al  igual que  antes, el  archivo comprimido
desaparece para dejar en su lugar la versión descomprimida.

\begin{verbatim}
[cila@gulic]$ gzip -d pepe.txt.gz
\end{verbatim}

Debido a la incomodidad de tener que comprimir/descomprimir para poder
acceder  a la  información son  muchos  los comandos  que cuentan  con
versiones especialmente diseñadas  para manipular archivos comprimidos
directamente. Es  el caso  de {\tt  zless}\index{Comandos!zless}, {\tt
zgrep}\index{Comandos!zgrep},  {\tt  zcat}\index{Comandos!zcat},  {\tt
zmore}\index{Comandos!zmore}, etc\dots

Pese  a lo  extendido  del uso  de  {\tt gzip}  en  la actualidad  hay
muchos otros  algoritmos con  ratios de  compresión mayores.  Por ello
se  han  creado comandos  compatibles,  en  cuanto  a opciones  de  la
línea  de  comandos,  con  {\tt   gzip},  pero  que  implementan  esos
otros  algoritmos. Es  el  caso  de {\tt  bzip2}\index{Comandos!bzip2}
y   de   los   comandos  {\tt   bzless}\index{Comandos!bzless},   {\tt
bzgrep}\index{Comandos!bzgrep},   {\tt   bzcat}\index{Comandos!bzcat},
{\tt bzmore}\index{Comandos!bzmore}, etc\dots

\subsection{El comando {\tt tar}}
\index{Comandos!tar}

El  comando {\tt  tar} permite  la  manipulación de  {\em ficheros  de
archivo} en  formato {\sf TAR}.  Dichos ficheros están  diseñados para
almacenar uno  o más  ficheros y/o directorios  y toda  la información
relacionada con  los mismos. Entre  esa información se  encuentran las
fechas  de acceso  y modificación,  los permisos,  el propietario,  el
grupo,  etc. El  origen del  comando {\tt  tar} se  remonta al  uso de
dipositivos sencuenciales  (como por  ejemplo cintas  magnéticas) para
almacenar  copias de  seguridad de  los  archivos del  sistema. En  la
actualidad no  es sino  una forma  de empaquetar  en un  único archivo
pedazos concretos del árbol de directorios de nuestro sistema.

Para crear  un archivo {\sf  TAR} basta  con que utilicemos  la opción
{\tt -c} seguida por la lista de ficheros y/o directorios que queremos
empaquetar. En general el archivo {\sf TAR} resultante se vuelca  a la
{\em  salida  estándar}.  Puesto  que eso  resulta  poco  práctico  es
habitual utilizar la opción {\tt -f} seguida del nombre del fichero de
destino.

\begin{verbatim}
[cila@gulic]$ tar -cf fichero.tar pepe.txt juan.txt /bin
\end{verbatim}

En el ejemplo  anterior {\tt fichero.tar} almacena  tanto los ficheros
{\tt pepe.txt} y {\tt juan.txt}  como el contenido del directorio {\tt
/bin}.

Los datos almacenados en los  ficheros {\sf TAR} no están comprimidos.
Por  ello es  habitual  utilizar  las opciones  {\tt  -z}  o {\tt  -j}
para  que {\tt  tar} pase  el  fichero por  {\tt gzip}  o {\tt  bzip2}
respectivamente, cuando termine de empaquetar los ficheros.

\begin{verbatim}
[cila@gulic]$ tar -zcf fichero.tar.gz pepe.txt /bin
\end{verbatim}

Para recuperar los ficheros originales se sustituye la opción {\tt -c}
por {\tt  -x}, mientras que  para verificar la integridad  del archivo
sin tener que desempaquetarlo se utiliza la opción {\tt -t}.

\begin{verbatim}
[cila@gulic]$ tar -xf fichero.tar
[cila@gulic]$ tar -zxf fichero.tar.gz
[cila@gulic]$ tar -ztf fichero.tar.gz
\end{verbatim}

\subsection{El comando {\tt grep}}
\index{Comandos!grep}

Cuando deseamos  localizar un cadena de  texto dentro de uno  o varios
ficheros  solemos  recurrir  al  comando  {\tt  grep}.  Dicho  comando
requiere que  se especifique la cadena  de texto a buscar  seguida del
nombre de  los ficheros en  los que  realizar la búsqueda.  Puesto que
alguno de los  caracteres de la cadena de texto  a buscar pueden tener
algún significado especial  para la interfaz de  comandos dicha cadena
suele ir entrecomillada.

\begin{verbatim}
[cila@gulic]$ grep 'cila' *
[cila@gulic]$ grep 'CaSa' pepe.txt
\end{verbatim}

Como  se puede  observar, en  el  primer ejemplo  estamos buscando  la
cadena  de  texto \verb|'cila'|  dentro  de  todos los  ficheros  del
directorio actual.

En  general {\tt  grep}  es  sensible a  mayúsculas  y minúsculas.  Si
queremos eliminar dicho comportamiento  podemos emplear la opción {\tt
-i}.  También  podemos pedir  que  nos  indique  dónde {\bf  NO}  está
la  cadena indicada  utilizando  la  opción {\tt  -v}.  Por otro  lado
las  búsquedas  pueden  extenderse por  directorios  y  subdirectorios
utilizando la opción {\tt -r}.

En realidad  {\tt grep} no  sólo nos permite utilizar  simples cadenas
para buscar dentro  de los ficheros indicados. El  comandos {\tt grep}
nos permite utilizar {\em expresiones  regulares}. Es decir, dentro de
nuestra cadena de texto podemos utilizar caracteres con un significado
especial con los  que podemos buscar casi cualquier  tipo de expresión
entre nuestros archivos. Puesto que las expresiones regulares se salen
completamente  del  alcance de  este  tema  recomendamos consultar  el
tema correspondiente.

\begin{verbatim}
[cila@gulic]$ man grep
\end{verbatim}

\subsection{Otros comandos}

\begin{description}

\item [clear]\index{Comandos!clear}  Limpia la pantalla de  la consola
(tecla {\tt C-l})

\item  [locate]\index{Comandos!locate} Es  la  orden  de búsqueda  más
rápida y sencilla para localizar un archivo.

\item  [reset]\index{Comandos!reset} Si  observamos que  escribimos en
pantalla y no aparece el texto pero al pulsar {\tt Enter} realmente se
está escribiendo,  o que  los colores  o los textos  de la  consola se
corrompen,  puede  ser  que  alguna  aplicación  en  modo  texto  haya
finalizado  bruscamente  no restaurando  los  valores  estándar de  la
consola  al  salir.  Con  esto  forzamos  unos  valores  por  defecto,
regenerando la pantalla.

\item [top]\index{Comandos!top}  Muestra los procesos que  se ejecutan
en  el  momento  actual,  informando  de los  recursos  que  se  están
consumiendo.

\item  [whoami]\index{Comandos!whoami}  El   curioso  nombre  de  este
comando proviene {\em  Who am I?} ({\em ¿Quién soy?}),  que indica que
este comando es capaz de informarnos  del nombre de usuario con que se
entró en esa consola. Puede parecer  una tontería, pero si una persona
entra en dos sesiones,  en una como {\tt root} y  en otra como usuario
normal,  si no  se  sabe  quién es  en  ese  momento, podrían  ocurrir
accidentes catastróficos.

\end{description}

\section{Unidades de disco}

Como hemos dicho anteriormente, en  Linux no existen las unidades como
{\tt A:} o {\tt C:}. Para acceder a un disco es necesario primero {\em
montarlo}\index{Montar}, esto  es asignarle un lugar  dentro del árbol
de directorios del sistema.

Por  ejemplo,  podemos asignar  a  la  disquetera el  directorio  {\tt
/floppy}, al CD-ROM el directorio {\tt /cdrom} o a la grabadora de CDs
el  directorio {\tt  /grabata}.  Normalmente los  directorios para  la
disquetera y el  lector de CD-ROM están ya asignados  desde el momento
de instalar el  sistema, aunque se puede cambiar a  voluntad (si somos
{\tt root}).

Para    montar     un    disco    utilizamos    el     comando    {\tt
mount}\index{Montar!mount} indicándole como  parámetros el dispositivo
al que queremos acceder, el directorio en el que lo queremos montar, y
el  sistema de  archivos utilizado  para ordenar  la información.  Sin
embargo,  el  administrador ({\tt  root})  suele  indicar todos  estos
parámetros  en el  fichero {\tt  fichero}, y  los usuarios  tienen que
conformarse montar lo  que {\tt root} les permita. En  nuestro caso el
señor {\tt root}  ha determinado que los usuarios  sólo podemos montar
la disquetera en el directorio {\tt /floppy}.

\begin{verbatim}
[cila@gulic]$ mount /dev/fd0 /floppy
mount: only root can do that
[cila@gulic]$ mount /floppy
\end{verbatim}

Una vez montado el disquete en  el directorio {\tt /floppy} ya podemos
acceder  y  manipular  sus  ficheros y  subdirectorios  como  más  nos
convenga. Desde la  perspectiva del usuario no  hay ninguna diferencia
entre trabajar en ese directorio y trabajar en otro cualquiera.

Pobre de quien  saque el disquete sin desmontarlo. ¿Por  qué? Pues por
tres razones:

\begin{enumerate}

\item  Existe el  riesgo de  que perdamos  la información  que hayamos
grabado en el disquete.

\item Ningún otro usuario podrá usar la disquetera, al menos hasta que
se reinicie el  ordenador o el {\tt root} tenga  tiempo para forzar el
que la unidad sea desmontanda, lo cual no le hará gracia a nadie.

\item El  Sr. root puede  mosquearse con quien lo  haga, y a  nadie le
conviene tener mosqueado al Sr. root.

\end{enumerate}

Para desmontar el disquete simplemente utilizamos el sencillo comando
{\tt umount}\index{Montar!umount}:

\begin{verbatim}
$ umount /floppy
\end{verbatim}

Como último ejemplo, hagamos lo siguiente:

\begin{verbatim}
$ mount /floppy
$ cd /floppy
$ umount /floppy
\end{verbatim}

¿Verdad que no funciona? Esto se debe a que en el momento de desmontar
la  disketera, {\bf  no debe  haber NADIE  dentro} de  ese directorio.
Recordemos que estamos en un  sistema multiusuario y puede ocurrir que
más  de una  persona  acceda  a la  disquetera  o  a otro  dispositivo
desmontable, como  el CD-ROM. Por  tanto, hemos de asegurarnos  que no
hay nadie.

Para comprobar en un momento dado  si el disquete está montado podemos
usar el comando {\tt df}\index{Comandos!df}, que nos informa sobre los
{\em  sistemas  de  ficheros}  que  están  montados  y  su  estado  de
almacenamiento.  La opción  {\tt  -h} nos  muestra  las cantidades  en
cifras {\em humanas}.

\begin{verbatim}
[cila@gulic]$ df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/hda2             1.9G  1.8G   80M  96% /
euler:/home            20G  3.2G   16G  17% /home
euler:/usr/soft       3.9G  5.4M  3.7G   0% /usr/soft
/dev/fd0              1.4M  758k  665k  53% /floppy
\end{verbatim}

Aquí  vemos  que la  segunda  partición  del  primer disco  duro  {\tt
/dev/hda2} está montada en el directorio {\tt /}, los directorios {\tt
/home} y  {\tt /usr/soft} del  servidor {\tt euler} están  montados en
sus equivalente locales, y el  disquete {\tt /dev/fd0} está montado en
el directorio {\tt /floppy}.

\section{Unidades de disco con mtools}

En general, la mayor parte de los disquetes que usamos están en
formato DOS/Windows.  Cuando disponemos de uno esos disquetes podemos
acceder a su contenido de forma sencilla con las {\sf
mtools}\index{mtools}.

{\sf mtools} es  una colección de herramientas de  dominio público que
permite a sistemas  UNIX manipular ficheros en un  sistema de archivos
DOS/Windows (típicamente un disquete). {\sf mtools} es suficiente para
dar acceso  a sistemas de  archivos DOS/Windows. Por  ejemplo, órdenes
como  {\tt mdir  a:}  funcionan en  el disquete  {\tt  A:} sin  ningún
montaje preliminar ni otro procedimiento  de inicio (suponiendo que el
{\tt /etc/mtools.conf}  sea correcto). Gracias  a todo ello,  con {\sf
mtools} se puede cambiar de disquete sin tener que desmontar y montar.

\subsection{Nombres de ficheros}

Muchas  de  las   herramientas  de  {\sf  mtools}   requieren  que  se
especifiquen nombres de archivo en  el sistema de archivos DOS/Windows
al que  estamos accediendo.  Las rutas  de ficheros  en el  sistema de
archivos DOS/Windows  se componen de:  una {\em letra  de dispositivo}
seguida de  dos puntos, un subdirectorio  y un nombre de  fichero. Los
nombres de  directorio pueden  emplear como separador  {\tt /}  o {\tt
$\backslash$}. El  uso del  separador {\tt $\backslash$}  requiere que
los nombres se entrecomillen para protegerlos, por lo que recomendamos
utilizar  {\tt /}  con  el fin  de evitar  problemas.  Los nombres  de
ficheros  que  no  van  precedidos  de una  letra  de  dispositivo  se
consideran ficheros del sistema UNIX.

Por ejemplo,  el siguiente  comando copia  el archivo  {\tt TEST1.TXT}
desde  el directorio  {\tt TEST}  del primer  dispositivo de  disquete
({\tt A:}), hasta nuestro directorio  de trabajo actual, con el nombre
de archivo {\tt test2.txt}.\label{mcopyej}

\begin{verbatim}
$ mcopy 'a:\TEST\TEST1.TXT' test2.txt
\end{verbatim}

que es completamente equivalente a:

\begin{verbatim}
$ mcopy a:/TEST/TEST1.TXT test2.txt
\end{verbatim}

Como  es obvio  las  {\sf  mtools} no  distinguen  entre mayúsculas  y
minúsculas  en  el acceso  al  sistema  de archivos  DOS/Windows.  Sin
embargo, si permiten la utilización de  comodines (como {\tt *} o {\tt
?}) tanto cuando especificamos un nombre de archivo Linux, como cuando
hacemos lo mismo con nombres de archivo DOS/Windows.

En cuanto a  las letras de dispositivo, comúnmente la  unidad {\tt A:}
es la  primera unidad de  disquete, la unidad  {\tt B:} es  la segunda
unidad de disquete,  la unidad {\tt J:}  es una unidad {\em  Jaz} y la
unidad  {\tt Z:}  es  una  unidad {\em  Zip}.  Sin  embargo todo  esto
puede   configurarse  mediante  el fichero  de  configuración  {\tt
/etc/mtools.conf}.

\subsection {Lista de comandos}

A continuación presentamos  algunos de los comandos  más utilizados de
las {\sf mtools}.

\subsubsection{mattrib}\index{mtools!mattrib}

Se emplea para cambiar los  atributos de ficheros DOS/Windows de forma
semejante a como lo hace el comando {\tt ATTRIB} del MS-DOS.

\subsubsection{mcd}\index{mtools!mcd}

El comando {\tt mcd } se  emplea para cambiar el directorio de trabajo
actual de {\sf mtools} en los discos DOS/Windows.

\begin{verbatim}
$ mcd <directorio_dos>
\end{verbatim}

Sin argumentos, {\tt mcd} informa de la unidad y directorio de trabajo
actuales. De otra forma, mcd cambia la unidad en curso y el directorio
de trabajo relativos a un sistema de archivos DOS/Windows.

Por ejemplo, si ejecutamos la siguiente secuencia de comandos:

\begin{verbatim}
$ mcd a:/TEST
$ mcopy a:TEST1.TXT test2.txt
\end{verbatim}

Copiaríamos  el  archivo  {\tt  TEST1.TXT}   tal  y  como  lo  hicimos
anteriormente (página \pageref{mcopyej}).

A diferencia de los sistemas DOS/Windows, con {\sf mtools} sólo hay un
directorio  de  trabajo  actual  para  todas las  unidades,  y  no  un
directorio de trabajo diferente para cada unidad.

\subsubsection{mcopy}\index{mtools!mcopy}

El comando {\tt mcopy} permite  copiar ficheros desde o hacia sistemas
de archivos DOS/Windows. Las formas de uso son:

\begin{verbatim} 
$ mcopy fichero_fuente fichero_destino
$ mcopy fichero_fuente <fichero_fuente> directorio_destino
$ mcopy fichero_fuente_dos
\end{verbatim}

El comando copia el {\tt fichero\_fuente} al {\tt fichero\_destino}, o
copia múltiples ficheros  al directorio de destino  indicado. Fuente y
destino pueden ser ficheros de DOS o de Linux. La presencia, o no, del
indicador de  letra del dispositivo  es el que determina  qué ficheros
son de DOS y cuáles de Linux.

Si sólo  se suministra uno  de los  parámetros fuente, se  supone como
destino el directorio actual de trabajo en el sistema Linux.

\subsubsection{mdel}\index{mtools!mdel}

El comando {\tt mdel} se emplea para borrar ficheros.

\begin{verbatim}
$ mdel fichero_dos
\end{verbatim}

Por ejemplo:

\begin{verbatim}
$ mdel a:/TEST2.TXT
\end{verbatim}

\subsubsection{mdeltree}\index{mtools!mdeltree}

El  comando  {\tt  mdeltree}  se utiliza  para  borrar  un  directorio
DOS/Windows y todos sus archivos y subdirectorios.

\begin{verbatim}
$ mdeltree directorio_dos
\end{verbatim}

\subsubsection{mdir}\index{mtools!mdir}

El  comando {\tt  mdir}  se emplea  para mostrar  el  contenido de  un
directorio DOS/Windows.

\begin{verbatim}
$ mdir <directorio_dos>
\end{verbatim}

Por ejemplo:

\begin{verbatim}
$ mdir a:
 Volume in drive A has no label
 Volume Serial Number is 3E48-13E9
Directory for A:/

TRABAJO  TXT     13838 11-01-1993   3:11
PROGRA~1 EXE    268232 12-14-2002  22:15  programinstall.exe
TEST         <DIR>     12-14-2002  22:13
        3 files             282 070 bytes
                          1 174 528 bytes free
\end{verbatim}

\subsubsection{mformat}\index{mtools!mformat}

El comando {\tt mformat} se utiliza  para crear un sistema de archivos
DOS/Windows vacio en la unidad indicada.

\begin{verbatim}
$ mformat <unidad:>
\end{verbatim}

\subsubsection{mmd}\index{mtools!mmd}

El comando  {\tt mmd} se emplea  para crear un nuevo  directorio en un
sistema  de archivos  DOS.  El comando  informará de  un  error si  el
directorio ya existe.

\begin{verbatim}
$ mmd directorio_dos
\end{verbatim}

\subsubsection{mmove}\index{mtools!mmove}

El comando {\tt  mmove} se utiliza para mover o  renombra un fichero o
subdirectorio  existente en  un sistema  de archivos  DOS/Windows. Las
formas de uso son:

\begin{verbatim} 
$ mmove fichero_fuente fichero_destino
$ mmove fichero_fuente <fichero_fuente> directorio_destino
$ mmove directorio_fuente directorio_destino
\end{verbatim}

\subsubsection{mrd}\index{mtools!mrd}

El comando {\tt mrd} se emplea para borrar un directorio de un sistema
de  archivos  DOS/Windows. El  comando  volverá  con  un error  si  el
directorio no existe o no está vacío.

\begin{verbatim}
$ mrd directorio_dos
\end{verbatim}

\subsubsection{mtype}\index{mtools!mtype}

El  comando  {\tt mtype}  muestra  el fichero  DOS/Windows
especificado, en la pantalla o en la salida estándar.

\begin{verbatim}
$ mtype fichero_dos
\end{verbatim}

Con este capítulo quedan explicados los rudimentos para saber moverse
por Linux.
\\
¡Feliz exploración!
